C51 COMPILER V9.00   FOCCONTROL                                                            01/15/2025 09:25:07 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FOCCONTROL
OBJECT MODULE PLACED IN .\Debug\FocControl.obj
COMPILER INVOKED BY: E:\KEIL\KEIL4\C51\BIN\C51.EXE ..\User\source\Function\FocControl.c LARGE OMF2 BROWSE INCDIR(..\FU68
                    -xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\FocControl.lst) OBJECT(.\Debug\FocControl.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2021 Fortiortech ShenZhen -----------------------------
   2              File Name      : FocControl.c
   3              Author         : Lewis.wang
   4              Version        : V1.0
   5              Date           : 2021-12-04
   6              Description    : This file contains FocControl function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          
  11          #include <FU68xx_4.h>
  12          #include <Myproject.h>
  13          /**
  14           * @brief     ÁîµÊú∫ÊéßÂà∂Áä∂ÊÄÅÊú∫
  15           * @warning   ÁîµÊú∫ÁöÑÁä∂ÊÄÅÂè™ËÉΩÂú®ÁîµÊú∫Áä∂ÊÄÅÊéßÂà∂‰∏≠ÂàáÊç¢ÔºåÁ¶ÅÊ≠¢Âú®ÂÖ∂‰ªñÂú∞ÊñπÂàáÊç¢ÁîµÊú∫Áä∂ÊÄ
             -Å
  16           */
  17          void MC_Control(void)
  18          {
  19   1          switch (mcState)
  20   1          {
  21   2              case mcReady:
  22   2                  if (mcFaultSource != FaultNoSource)
  23   2                  {
  24   3                      mcState = mcFault;
  25   3                  }
  26   2                  else
  27   2                  {
  28   3                      /* -----Motor_Ready----- */
  29   3                      Motor_Ready();
  30   3                      
  31   3                      if ((mcCurOffset.OffsetFlag == 1) && (mcSpeedRamp.FlagONOFF == 1) && (mcFocCtrl.mcDcbusFlt
             - > UNDER_RECOVER_VALUE))     //Á≠âÂæÖÁîµË∑ØÊ†°ÂáÜÁªìÊùüÔºåÂπ∂‰∏îÊî∂Âà∞ÂêØÂä®‰ø°Âè∑Ë∑≥ËΩ¨InitÁä∂ÊÄÅ
  32   3                      {
  33   4                          mcState = mcInit;
  34   4                          mcCurOffset.OffsetFlag = 0;
  35   4                          mcCurOffset.OffsetCount = 0;
  36   4                      }
  37   3                  }
  38   2                  
  39   2                  break;
  40   2                  
  41   2              case mcInit:
  42   2                  if (mcFaultSource != FaultNoSource)
  43   2                  {
  44   3                      mcState = mcFault;
  45   3                  }
  46   2                  else if (mcSpeedRamp.FlagONOFF == 0)
  47   2                  {
  48   3                      mcState = mcStop;
  49   3                  }
  50   2                  else
  51   2                  {
  52   3                      if (mcCurOffset.OffsetFlag == 1)
C51 COMPILER V9.00   FOCCONTROL                                                            01/15/2025 09:25:07 PAGE 2   

  53   3                      {
  54   4                          /* -----Motor_Init----- */
  55   4                          Motor_Init();
  56   4                          #if (IPMState == IPMtest)
                                  {
                                      mcState               = mcCharge;
                                      mcFocCtrl.State_Count = 100;
                                  }
                                  #else
  62   4                          {
  63   5                              mcState              = mcTailWind;
  64   5                          }
  65   4                          #endif
  66   4                      }
  67   3                  }
  68   2                          
  69   2                  break;
  70   2                          
  71   2              case mcCharge:
  72   2                  if (mcFaultSource != FaultNoSource)
  73   2                  {
  74   3                      mcState = mcFault;
  75   3                  }
  76   2                  else if (mcSpeedRamp.FlagONOFF == 0)
  77   2                  {
  78   3                      mcState = mcStop;
  79   3                  }
  80   2                  else
  81   2                  {
  82   3                      Motor_Charge();
  83   3                  }
  84   2                          
  85   2                  break;
  86   2                          
  87   2              case mcTailWind:
  88   2                  if (mcFaultSource != FaultNoSource)
  89   2                  {
  90   3                      mcState = mcFault;
  91   3                  }
  92   2                  else if (mcSpeedRamp.FlagONOFF == 0)
  93   2                  {
  94   3                      mcState = mcStop;
  95   3                  }
  96   2                  else
  97   2                  {
  98   3                      #if (TailWind_Mode == NoTailWind)
                              {
                                  mcState = mcAlign;
                                  
                                  mcFocCtrl.State_Count = Align_Time;
                              }
                              #else
 105   3                      {
 106   4                          /* -----Êó†ÊÑüÈ°∫ÈÄÜÈ£é----- */
 107   4                          Motor_TailWind();
 108   4                          if (mcFocCtrl.TailWindStatus == Staticwind)
 109   4                          {
 110   5                              mcState = mcAlign;
 111   5                              mcFocCtrl.State_Count = Align_Time;
 112   5                          }
 113   4                          else if (mcFocCtrl.TailWindStatus == Downwind)
 114   4                          {
C51 COMPILER V9.00   FOCCONTROL                                                            01/15/2025 09:25:07 PAGE 3   

 115   5                              mcState = mcRun;
 116   5                          }
 117   4                      }
 118   3                      #endif
 119   3                  }
 120   2                          
 121   2                  break;
 122   2                          
 123   2              case mcAlign:
 124   2                  if (mcFaultSource != FaultNoSource)
 125   2                  {
 126   3                      mcState = mcFault;
 127   3                  }
 128   2                  else if (mcSpeedRamp.FlagONOFF == 0)
 129   2                  {
 130   3                      mcState = mcStop;
 131   3                  }
 132   2                  else
 133   2                  {
 134   3                      /* -----È¢ÑÂÆö‰Ωç----- */
 135   3                      Motor_Align();
 136   3                      #if (AlignTestMode == 1)
                              {
                                  _nop_();
                              }
                              #else
 141   3                      {
 142   4                          if (mcFocCtrl.State_Count == 0)
 143   4                          {
 144   5                              mcState = mcStart;                                                    //ÂÆö‰ΩçÁªìÊ
             -ùüÂêéÂêØÂä®
 145   5                          }
 146   4                      }
 147   3                      #endif
 148   3                  }
 149   2                          
 150   2                  break;
 151   2                          
 152   2              case mcStart:
 153   2                  if (mcFaultSource != FaultNoSource)
 154   2                  {
 155   3                      mcState = mcFault;
 156   3                  }
 157   2                  else if (mcSpeedRamp.FlagONOFF == 0)
 158   2                  {
 159   3                      mcState = mcStop;
 160   3                  }
 161   2                  else
 162   2                  {
 163   3                      /* -----Êó†ÊÑüÂêØÂä®----- */
 164   3                      Motor_Open();
 165   3                  }
 166   2                          
 167   2                  break;
 168   2                          
 169   2              case mcRun:
 170   2                  if (mcFaultSource != FaultNoSource)
 171   2                  {
 172   3                      mcState = mcFault;
 173   3                  }
 174   2                  else
 175   2                  {
C51 COMPILER V9.00   FOCCONTROL                                                            01/15/2025 09:25:07 PAGE 4   

 176   3                      if ((mcSpeedRamp.TargetValue == 0) || (mcSpeedRamp.FlagONOFF == 0))          //Âª∂ËøüÂÖ≥Êñ
             -≠ËæìÂá∫
 177   3                      {
 178   4                           mcState = mcStop;
 179   4                      }
 180   3                  }
 181   2                          
 182   2                  break;
 183   2                          
 184   2              case mcStop:
 185   2                  if (mcFaultSource != FaultNoSource)
 186   2                  {
 187   3                      mcState = mcFault;
 188   3                  }
 189   2                  else
 190   2                  {
 191   3                      #if (StopBrakeFlag == 0)
 192   3                      {
 193   4                          mcState = mcReady;
 194   4                          FOC_CR1 = 0x00;
 195   4                          ClrBit(DRV_CR, FOCEN);
 196   4                          ClrBit(DRV_CR, DRVEN);
 197   4                          MOE = 0;
 198   4                      }
 199   3                      #else
                              {
                                  if (mcFocCtrl.SpeedFlt < Motor_Stop_Speed)
                                  {
                                      MOE = 0;
                                      FOC_CR1 = 0x00;
                                      ClrBit(DRV_CR, FOCEN);
                                      DRV_DR   = DRV_ARR + 1;
                                      DRV_CMR &= 0xFFC0;;
                                      DRV_CMR |= 0x015;
                                      ClrBit(DRV_CR, OCS);
                                      MOE = 1;
                                      mcState  = mcBrake;
                                      mcFocCtrl.State_Count = StopWaitTime;
                                  }
                              }
                              #endif
 216   3                  }
 217   2                          
 218   2                  break;
 219   2                          
 220   2              case mcBrake:
 221   2                  if (mcFaultSource != FaultNoSource)
 222   2                  {
 223   3                      mcState = mcFault;
 224   3                  }
 225   2                  else
 226   2                  {
 227   3                      if (mcFocCtrl.State_Count == 0)
 228   3                      {
 229   4                          mcState = mcReady;
 230   4                          MOE = 0;
 231   4                          ClrBit(DRV_CR, FOCEN);
 232   4                      }
 233   3                  }
 234   2                          
 235   2                  break;
 236   2                          
C51 COMPILER V9.00   FOCCONTROL                                                            01/15/2025 09:25:07 PAGE 5   

 237   2              case mcFault:
 238   2                  FaultProcess();
 239   2                          
 240   2                  if (mcFaultSource == FaultNoSource)
 241   2                  {
 242   3                      mcState = mcReady;
 243   3                  }
 244   2                          
 245   2                  break;
 246   2                          
 247   2              default:
 248   2                  break;
 249   2          }
 250   1      }                    


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    415    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
