C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADDFUNCTION
OBJECT MODULE PLACED IN .\Debug\AddFunction.obj
COMPILER INVOKED BY: E:\KEIL\KEIL4\C51\BIN\C51.EXE ..\User\source\Application\AddFunction.c LARGE OMF2 BROWSE INCDIR(..\
                    -FU68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\AddFunction.lst) OBJECT(.\Debug\AddFunction.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2021 Fortiortech ShenZhen -----------------------------
   2              File Name      : AddFunction.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2021-12-28
   6              Description    : This file contains  function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include <FU68xx_4.h>
  11          #include <Myproject.h>
  12          
  13          FaultStateType       xdata   mcFaultSource;
  14          PWMINPUTCAL          xdata   mcPwmInput;
  15          FGout                xdata   FG;
  16          FOCCTRL              xdata   mcFocCtrl;
  17          ADCSample            xdata   AdcSampleValue;
  18          ONVarible            idata   ONOFFTest;
  19          MCRAMP               xdata   mcSpeedRamp;
  20          MotorFRTypeDef       xdata   mcFRState;
  21          int16                xdata   VSP;
  22          int16                xdata   VSP_LSB;
  23          Variable             xdata   Vari;
  24          CurrentOffset        xdata   mcCurOffset;
  25          MotStaType           xdata   mcState;
  26          MotStaM              xdata   McStaSet;
  27          UART2_Struct         xdata   uart2_data_t;
  28          Blower_State             xdata   blower_state_t;
  29          /* -------------------------------------------------------------------------------------------------
  30              Function Name  : FaultProcess
  31              Description    : ‰øùÊä§Â§ÑÁêÜÂáΩÊï∞ÔºåÂÖ≥Èó≠FOCËæìÂá∫ÔºåÂêåÊó∂Â∞ÜÁä∂ÊÄÅÂèò‰∏∫mcFault
  32              Date           : 2021-12-28
  33              Parameter      : None
  34          ------------------------------------------------------------------------------------------------- */
  35          void FaultProcess(void)
  36          {
  37   1          ClrBit(DRV_CR, FOCEN);
  38   1          ClrBit(DRV_CR, DRVEN);
  39   1          MOE     = 0;
  40   1      }
  41          
  42          /* -------------------------------------------------------------------------------------------------
  43              Function Name  : Fault_Detection
  44              Description    : ‰øùÊä§ÂáΩÊï∞
  45              Date           : 2021-12-28
  46              Parameter      : None
  47          ------------------------------------------------------------------------------------------------- */
  48          void Fault_Detection(void)
  49          {
  50   1          /* -----ËΩØ‰ª∂ËøáÊµÅ‰øùÊä§----- */
  51   1          Fault_Overcurrent();
  52   1          #if (VoltageProtectEnable)          //ËøáÂéã‰øùÊä§
  53   1          {
  54   2              Fault_OverUnderVoltage();
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 2   

  55   2          }
  56   1          #endif
  57   1          #if (StartProtectEnable)            //ÂêØÂä®‰øùÊä§‰ΩøËÉΩ
  58   1          {
  59   2              Fault_Start();
  60   2          }
  61   1          #endif
  62   1          #if (StallProtectEnable)            //Â†µËΩ¨‰øùÊä§‰ΩøËÉΩ
  63   1          {
  64   2              Fault_Stall();
  65   2          }
  66   1          #endif
  67   1          #if (PhaseLossProtectEnable)        //Áº∫Áõ∏‰øùÊä§‰ΩøËÉΩ
  68   1          {
  69   2              Fault_phaseloss();
  70   2          }
  71   1          #endif
  72   1          /* -----‰øùÊä§ÊÅ¢Â§ç----- */
  73   1          Fault_Recovery();
  74   1      }
  75          /* -------------------------------------------------------------------------------------------------
  76              Function Name  : ONOFF_Starttest
  77              Description    : ÂêØÂÅúÊµãËØï
  78              Date           : 2021-12-05
  79              Parameter      : h_test: [ËæìÂÖ•/Âá∫]
  80          ------------------------------------------------------------------------------------------------- */
  81          void ONOFF_Starttest(void)
  82          {
  83   1          if (ONOFFTest.ONOFF_Flag == 1)
  84   1          {
  85   2              ONOFFTest.ON_Count++;
  86   2              
  87   2              if (ONOFFTest.ON_Count > StartON_Time)
  88   2              {
  89   3                  ONOFFTest.ON_Count        = 0;
  90   3                  ONOFFTest.ONOFF_Times++;
  91   3                  ONOFFTest.ONOFF_Flag      = 0;
  92   3                  mcSpeedRamp.FlagONOFF   = 0;
  93   3                  mcSpeedRamp.TargetValue = 0;
  94   3              }
  95   2          }
  96   1          else
  97   1          {
  98   2              if (mcState != mcFault)
  99   2              {
 100   3                  ONOFFTest.OFF_Count++;
 101   3                  
 102   3                  if (ONOFFTest.OFF_Count >= StartOFF_Time)
 103   3                  {
 104   4                      ONOFFTest.OFF_Count       = 0;
 105   4                      ONOFFTest.ONOFF_Flag      = 1;
 106   4                      mcSpeedRamp.FlagONOFF   = 1;
 107   4                      mcSpeedRamp.TargetValue = MOTOR_ONOFF_Speed;
 108   4                  }
 109   3              }
 110   2          }
 111   1      }
 112          /* -------------------------------------------------------------------------------------------------
 113              Function Name  : Speed_response
 114              Description    : ÈÄüÂ∫¶ÂìçÂ∫îÂáΩÊï∞ÔºåÂèØÊ†πÊçÆÈúÄÊ±ÇÂä†ÂÖ•ÊéßÂà∂ÁéØÔºåÂ¶ÇÊÅíËΩ¨Áü©ÊéßÂà∂„ÄÅÊÅíËΩ¨ÈÄüÊ
             -éßÂà∂„ÄÅÊÅíÂäüÁéáÊéßÂà∂
 115              Date           : 2021-12-05
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 3   

 116              Parameter      : None
 117          ------------------------------------------------------------------------------------------------- */
 118          void Speed_response(void)
 119          {
 120   1          if ((mcState == mcRun) || (mcState == mcStop))
 121   1          {
 122   2              switch (mcFocCtrl.CtrlMode)
 123   2              {
 124   3                  case 0:  //ÂºÄÁéØ
 125   3                  {
 126   4                      #if (Open_Start_Mode == PLL_Start)
                          
                              if ((FOC__EOME > Motor_Loop_Speed) && (PLLfunction.PLLFunctionFlag > 1))
                              #else
 130   4                      if (FOC__EOME > Motor_Loop_Speed)
 131   4                      #endif
 132   4                      {
 133   5                          mcFocCtrl.CtrlMode = 1;                                 //ÂàáÈó≠ÁéØ
 134   5                          FOC_DQKP = DQKP;
 135   5                          FOC_DQKI = DQKI;
 136   5                          FOC_IDREF = 0;
 137   5                          FOC__THECOMP    = _Q15(2.0 / 180.0);                    // SMO ‰º∞ÁÆóË°•ÂÅøËßí
 138   5                          mcFocCtrl.TorqueLoopTime = SPEED_LOOP_TIME;
 139   5                          PI3_Init();
 140   5                          #if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL)
 141   5                          {
 142   6                              mcSpeedRamp.ActualValue = Motor_Loop_Speed;
 143   6                          }
 144   5                          #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL)
                                  {
                                      mcSpeedRamp.ActualValue = mcFocCtrl.Powerlpf;
                                  }
                                  #endif
 149   5                          PI2_UKH = mcFocCtrl.mcIqref;
 150   5                          PI3_UKH = mcFocCtrl.mcIqref;
 151   5                      }
 152   4                  }
 153   3                  break;
 154   3                  
 155   3                  case 1:  //Èó≠ÁéØ
 156   3                  {
 157   4                      mcFocCtrl.TorqueLoopTime++;
 158   4                      
 159   4                      if (mcFocCtrl.TorqueLoopTime > SPEED_LOOP_TIME)
 160   4                      {
 161   5                          mcFocCtrl.TorqueLoopTime = 0;
 162   5                          #if (OUTLoop_Mode == OUTLoop_Disable)
                                  {
                                      mcFocCtrl.mcIqref = FOC_IQREF;
                                      
                                      if (mcFocCtrl.mcIqref < QOUTMAXVALUE)
                                      {
                                          mcFocCtrl.mcIqref += QOUTINC;
                                          
                                          if (mcFocCtrl.mcIqref > QOUTMAXVALUE)
                                          {
                                              mcFocCtrl.mcIqref = QOUTMAXVALUE;
                                          }
                                          
                                          FOC_IQREF = mcFocCtrl.mcIqref;
                                      }
                                      else if (mcFocCtrl.mcIqref > QOUTMAXVALUE)
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 4   

                                      {
                                          mcFocCtrl.mcIqref -= QOUTINC;
                                          
                                          if (mcFocCtrl.mcIqref < QOUTMAXVALUE)
                                          {
                                              mcFocCtrl.mcIqref = QOUTMAXVALUE;
                                          }
                                          
                                          FOC_IQREF = mcFocCtrl.mcIqref;
                                      }
                                      else
                                      { FOC_IQREF = mcFocCtrl.mcIqref; }
                                  }
                                  #elif (OUTLoop_Mode == OUTLoop_Enable)
 192   5                          {
 193   6                              mc_ramp();
 194   6                              #if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL) //ÈÄüÂ∫¶ÁéØ
 195   6                              {
 196   7                                  mcFocCtrl.mcIqref = HW_One_PI3(mcSpeedRamp.ActualValue - mcFocCtrl.SpeedFlt);
 197   7                                  FOC_IQREF = mcFocCtrl.mcIqref;
 198   7                              }
 199   6                              #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL) //ÂäüÁéáÁéØ
                                      {
                                          mcFocCtrl.mcIqref = HW_One_PI3(mcSpeedRamp.ActualValue - mcFocCtrl.Powerlpf);
                                          FOC_IQREF = mcFocCtrl.mcIqref;
                                      }
                                      #endif
 205   6                          }
 206   5                          #endif
 207   5                          
 208   5                          if (FOC_EK2 < OBS_K2T_Actual - 10)
 209   5                          {
 210   6                              mcFocCtrl.Smo_EK2  = FOC_EK2;
 211   6                              mcFocCtrl.Smo_EK2 += 10;
 212   6                              FOC_EK2 = mcFocCtrl.Smo_EK2;
 213   6                          }
 214   5                          else if (FOC_EK2 > OBS_K2T_Actual + 10)
 215   5                          {
 216   6                              mcFocCtrl.Smo_EK2  = FOC_EK2;
 217   6                              mcFocCtrl.Smo_EK2 -= 10;
 218   6                              FOC_EK2 = mcFocCtrl.Smo_EK2;
 219   6                          }
 220   5                          else
 221   5                          {
 222   6                              FOC_EK2 = OBS_K2T_Actual;
 223   6                          }
 224   5                      }
 225   4                  }
 226   3                  break;
 227   3              }
 228   2          }
 229   1      }
 230          
 231          
 232          /* -------------------------------------------------------------------------------------------------
 233              Function Name  : mc_ramp
 234              Description    : Áà¨Âù°ÂáΩÊï∞
 235              Date           : 2021-12-05
 236              Parameter      : hSpeedramp: [ËæìÂÖ•/Âá∫]
 237          ------------------------------------------------------------------------------------------------- */
 238          void mc_ramp(void)
 239          {
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 5   

 240   1          if ( --mcSpeedRamp.DelayCount < 0)
 241   1          {
 242   2              mcSpeedRamp.DelayCount = mcSpeedRamp.DelayPeriod;
 243   2              
 244   2              if (mcSpeedRamp.ActualValue < mcSpeedRamp.TargetValue)
 245   2              {
 246   3                  if (mcSpeedRamp.ActualValue + Motor_Speed_Inc < mcSpeedRamp.TargetValue)
 247   3                  {
 248   4                      mcSpeedRamp.ActualValue += Motor_Speed_Inc;
 249   4                  }
 250   3                  else
 251   3                  {
 252   4                      mcSpeedRamp.ActualValue = mcSpeedRamp.TargetValue;
 253   4                  }
 254   3              }
 255   2              else
 256   2              {
 257   3                  if (mcSpeedRamp.ActualValue - Motor_Speed_Dec > mcSpeedRamp.TargetValue)
 258   3                  {
 259   4                      mcSpeedRamp.ActualValue -= Motor_Speed_Dec;
 260   4                  }
 261   3                  else
 262   3                  {
 263   4                      mcSpeedRamp.ActualValue = mcSpeedRamp.TargetValue;
 264   4                  }
 265   3              }
 266   2          }
 267   1      }
 268          
 269          /* -------------------------------------------------------------------------------------------------
 270              Function Name  : HW_One_PI3
 271              Description    : PI3ÊéßÂà∂
 272              Date           : 2021-12-05
 273              Parameter      : Xn1: [ËæìÂÖ•/Âá∫]
 274          ------------------------------------------------------------------------------------------------- */
 275          int16 HW_One_PI3(int16 Xn1)
 276          {
 277   1          PI3_EK = Xn1;
 278   1          SetBit(PI_CR, PI3STA);
 279   1          
 280   1          while (ReadBit(PI_CR, PIBSY));
 281   1          
 282   1          return PI3_UKH;
 283   1      }
 284          
 285          /* -------------------------------------------------------------------------------------------------
 286              Function Name  : HW_one_PI2
 287              Description    : PI2ÊéßÂà∂
 288              Date           : 2021-12-05
 289              Parameter      : Xn1: [ËæìÂÖ•/Âá∫]
 290          ------------------------------------------------------------------------------------------------- */
 291          int16 HW_one_PI2(int16 Xn1)
 292          {
 293   1          PI2_EK = Xn1;
 294   1          SetBit(PI_CR, PI2STA);
 295   1          
 296   1          while (ReadBit(PI_CR, PIBSY));
 297   1          
 298   1          return PI2_UKH;
 299   1      }
 300          
 301          /*---------------------------------------------------------------------------*/
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 6   

 302          /* Name     :   void VSPSample(void)
 303          /* Input    :   NO
 304          /* Output   :   NO
 305          /* Description: VSPÈááÊ†∑
 306          /*---------------------------------------------------------------------------*/
 307          void VSPSample(void)
 308          {
 309   1          /*****VREFÁöÑÈááÊ†∑Ëé∑ÂèñÂÄºÂπ∂Êª§Ê≥¢******/
 310   1          AdcSampleValue.ADCSpeed = (ADC7_DR);        //ÈááÈõÜÂØπÂ∫îÁ´ØÂè£
 311   1          LPF_MDU(AdcSampleValue.ADCSpeed, 30, VSP, VSP_LSB);   //‰ΩéÈÄöÊª§Ê≥¢
 312   1          
 313   1          if (VSP > ONPWMDuty)
 314   1          {
 315   2              mcSpeedRamp.VSP_Off_count = 0;
 316   2              
 317   2              if (++mcSpeedRamp.VSP_On_count > 100)
 318   2              {
 319   3                  mcSpeedRamp.VSP_On_count = 100;
 320   3                  mcSpeedRamp.FlagONOFF = 1;
 321   3              }
 322   2          }
 323   1          else if (VSP < OFFPWMDuty)
 324   1          {
 325   2              mcSpeedRamp.VSP_On_count = 0;
 326   2              
 327   2              if (++mcSpeedRamp.VSP_Off_count > 100)
 328   2              {
 329   3                  mcSpeedRamp.VSP_Off_count = 100;
 330   3                  mcSpeedRamp.FlagONOFF = 0;
 331   3              }
 332   2          }
 333   1          
 334   1          //ËΩ¨ÈÄüÊõ≤Á∫øËÆ°ÁÆó
 335   1          if (mcSpeedRamp.FlagONOFF == 1) //
 336   1          {
 337   2              #if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL)
 338   2              {
 339   3                  if (VSP <= MINPWMDuty)   //ÊúÄÂ∞èËΩ¨ÈÄüËøêË°å
 340   3                  {
 341   4                      mcSpeedRamp.TargetValue = Motor_Min_Speed;
 342   4                  }
 343   3                  else if (VSP < MAXPWMDuty) //Ë∞ÉÈÄü
 344   3                  {
 345   4                      mcSpeedRamp.TargetValue = Motor_Min_Speed + SPEED_K * (VSP - MINPWMDuty);
 346   4                  }
 347   3                  else                    //ÊúÄÂ§ßËΩ¨ÈÄüËøêË°å
 348   3                  {
 349   4                      mcSpeedRamp.TargetValue = Motor_Max_Speed;
 350   4                  }
 351   3              }
 352   2              #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL)
                      {
                      
                          if (VSP <= MINPWMDuty)   //ÊúÄÂ∞èËΩ¨ÈÄüËøêË°å
                          {
                              mcSpeedRamp.TargetValue = MOTOR_POWER_MIN_RPM;
                          }
                          else if (VSP < MAXPWMDuty) //Ë∞ÉÈÄü
                          {
                              mcSpeedRamp.TargetValue = MOTOR_POWER_MIN_RPM + POWER_K * (VSP - MINPWMDuty);
                          }
                          else             //ÊúÄÂ§ßËΩ¨ÈÄüËøêË°å
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 7   

                          {
                              mcSpeedRamp.TargetValue = MOTOR_POWER_MAX_RPM;
                          }
                      }
                      #endif
 369   2          }
 370   1          else
 371   1          {
 372   2              mcSpeedRamp.TargetValue = 0;
 373   2          }
 374   1      }
 375          /* -------------------------------------------------------------------------------------------------
 376              Function Name  : StarRampDealwith
 377              Description    : ÁîµÊú∫ÂêØÂä®Áà¨Âù°ÂáΩÊï∞Â§ÑÁêÜ
 378              Date           : 2021-12-05
 379              Parameter      : None
 380          ------------------------------------------------------------------------------------------------- */
 381          void StarRampDealwith(void)
 382          {
 383   1          if (mcFocCtrl.CtrlMode == 0)
 384   1          {
 385   2              #if (Open_Start_Mode == PLL_Start)
                      {
                          RampFucntion();
                      }
                      #endif
 390   2              
 391   2              if ( mcFocCtrl.mcIqref < IQ_Start_CURRENT)
 392   2              {
 393   3                  mcFocCtrl.mcIqref  += 10;
 394   3                  FOC_IQREF = mcFocCtrl.mcIqref;
 395   3              }
 396   2          }
 397   1          
 398   1          if ((mcState == mcRun))
 399   1          {
 400   2              if (mcFocCtrl.State_Count == 1000)
 401   2              {
 402   3                  FOC_EKP = OBSW_KP_GAIN_RUN;              // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
 403   3                  FOC_EKI = OBSW_KI_GAIN_RUN;              // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
 404   3              }
 405   2              else if (mcFocCtrl.State_Count == 800)
 406   2              {
 407   3                  FOC_EKP = OBSW_KP_GAIN_RUN1;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
 408   3                  FOC_EKI = OBSW_KI_GAIN_RUN1;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
 409   3              }
 410   2              else if (mcFocCtrl.State_Count == 600)
 411   2              {
 412   3                  FOC_EKP = OBSW_KP_GAIN_RUN2;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
 413   3                  FOC_EKI = OBSW_KI_GAIN_RUN2;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
 414   3              }
 415   2              else if (mcFocCtrl.State_Count == 400)
 416   2              {
 417   3                  FOC_EKP = OBSW_KP_GAIN_RUN3;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
 418   3                  FOC_EKI = OBSW_KI_GAIN_RUN3;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
 419   3              }
 420   2              else if (mcFocCtrl.State_Count == 200)
 421   2              {
 422   3                  FOC_EKP = OBSW_KP_GAIN_RUN4;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKP
 423   3                  FOC_EKI = OBSW_KI_GAIN_RUN4;             // ‰º∞ÁÆóÂô®ÈáåÁöÑPIÁöÑKI
 424   3              }
 425   2          }
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 8   

 426   1      }
 427          
 428          /* -------------------------------------------------------------------------------------------------
 429              Function Name  : PWMInputCapture
 430              Description    : ËæìÂÖ•PWMÂ§ÑÁêÜ
 431              Date           : 2021-12-05
 432              Parameter      : None
 433          ------------------------------------------------------------------------------------------------- */
 434          void PWMInputCapture(void)
 435          {
 436   1          if (mcPwmInput.PWMUpdateFlag == 1)
 437   1          {
 438   2              DivQ_L_MDU(mcPwmInput.PWMCompare >> 1, 0x0000, mcPwmInput.PWMARR, mcPwmInput.PWMDuty);
 439   2              
 440   2              if ((mcPwmInput.PWMDuty > ONPWMDuty))                                                         //Â§
             -ß‰∫éÂºÄÊú∫Âç†Á©∫ÊØîÂºÄÊú∫
 441   2              {
 442   3                  if (++mcPwmInput.OnCount >= 30)
 443   3                  {
 444   4                      mcPwmInput.OnCount = 30;                                                              //Âº
             -ÄÊú∫Âª∂Êó∂
 445   4                      mcSpeedRamp.FlagONOFF = 1;
 446   4                  }
 447   3              }
 448   2              else
 449   2              {
 450   3                  mcPwmInput.OnCount = 0;
 451   3              }
 452   2              
 453   2              if (mcPwmInput.PWMDuty < OFFPWMDuty)                                                          //Â∞
             -è‰∫éÂÖ≥Êú∫Âç†Á©∫ÊØîÂÖ≥Êú∫
 454   2              {
 455   3                  if (++mcPwmInput.OffCount >= 20)
 456   3                  {
 457   4                      mcPwmInput.OffCount = 20;                                                             //ÂÖ
             -≥Êú∫Âª∂Êó∂
 458   4                      mcSpeedRamp.FlagONOFF = 0;
 459   4                  }
 460   3              }
 461   2              else
 462   2              {
 463   3                  mcPwmInput.OffCount = 0;
 464   3              }
 465   2              
 466   2              if (mcSpeedRamp.FlagONOFF == 1)
 467   2              {
 468   3                  #if (Motor_Speed_Control_Mode == SPEED_LOOP_CONTROL) //ÈÄüÂ∫¶ÁéØ
 469   3                  {
 470   4                      if (mcPwmInput.PWMDuty < MINPWMDuty)
 471   4                      {
 472   5                          mcSpeedRamp.TargetValue = Motor_Min_Speed;
 473   5                      }
 474   4                      else if (mcPwmInput.PWMDuty <= MAXPWMDuty)
 475   4                      {
 476   5                          mcSpeedRamp.TargetValue = Motor_Min_Speed + SPEED_K * (mcPwmInput.PWMDuty - MINPWMDuty
             -) ;
 477   5                      }
 478   4                      else
 479   4                      { mcSpeedRamp.TargetValue = Motor_Max_Speed; }
 480   4                      
 481   4                  }
 482   3                  #elif (Motor_Speed_Control_Mode == POWER_LOOP_CONTROL) //ÂäüÁéáÁéØ
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 9   

                          {
                              if (mcPwmInput.PWMDuty < MINPWMDuty)
                              {
                                  mcSpeedRamp.TargetValue = MOTOR_POWER_MIN_RPM;
                              }
                              else if (mcPwmInput.PWMDuty <= MAXPWMDuty)
                              {
                                  mcSpeedRamp.TargetValue = MOTOR_POWER_MIN_RPM + POWER_K * (mcPwmInput.PWMDuty - MINPWM
             -Duty) ;
                              }
                              else
                              { mcSpeedRamp.TargetValue = MOTOR_POWER_MAX_RPM; }
                          }
                          #endif
 496   3              }
 497   2              else
 498   2              {
 499   3                  mcSpeedRamp.TargetValue = 0;
 500   3              }
 501   2          }
 502   1          
 503   1          mcPwmInput.PWMUpdateFlag = 0;
 504   1      }
 505          
 506          
 507          void Fault_GetCurrentOffset(void)
 508          {
 509   1          if (mcCurOffset.OffsetFlag == 1)
 510   1          {
 511   2              #if (Shunt_Resistor_Mode == Single_Resistor)                   //ÂçïÁîµÈòªÊ®°Âºè
 512   2              {
 513   3                  if ((mcCurOffset.Iw_busOffset < GetCurrentOffsetValueLow) || (mcCurOffset.Iw_busOffset > GetCu
             -rrentOffsetValueHigh))
 514   3                  {
 515   4                      mcFaultSource = FaultGetOffset;
 516   4                  }
 517   3              }
 518   2              #elif (Shunt_Resistor_Mode == Double_Resistor)                 //ÂèåÁîµÈòªÊ®°Âºè
                      {
                          if ((mcCurOffset.IuOffset < GetCurrentOffsetValueLow) || (mcCurOffset.IuOffset > GetCurrentOff
             -setValueHigh)
                              || (mcCurOffset.IvOffset < GetCurrentOffsetValueLow) || (mcCurOffset.IvOffset > GetCurrent
             -OffsetValueHigh))
                          {
                              mcFaultSource = FaultGetOffset;
                          }
                      }
                      #elif (Shunt_Resistor_Mode == Three_Resistor)                 //‰∏âÁîµÈòªÊ®°Âºè
                      {
                          if ((mcCurOffset.IuOffset < GetCurrentOffsetValueLow) || (mcCurOffset.IuOffset > GetCurrentOff
             -setValueHigh)
                              || (mcCurOffset.IvOffset < GetCurrentOffsetValueLow) || (mcCurOffset.IvOffset > GetCurrent
             -OffsetValueHigh)
                              || (mcCurOffset.Iw_busOffset < GetCurrentOffsetValueLow) || (mcCurOffset.Iw_busOffset > Ge
             -tCurrentOffsetValueHigh))
                          {
                              mcFaultSource = FaultGetOffset;
                          }
                      }
                      #endif
 536   2          }
 537   1      }
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 10  

 538          /**
 539           * @function     Function_1_MS_
 540          *  @brief        1ms‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞
 541           * @param[in]    None
 542           * @return       None
 543           * @date         2024-08-26
 544          */
 545          void Function_1_MS_(uint32 speed)
 546          {
 547   1          SetBit(ADC_CR, ADCBSY);                                                               //‰ΩøËÉΩADCÁöÑDC
             -BUSÈááÊ†∑
 548   1          Vari.UQ     = FOC__UQ;
 549   1          Vari.QMAX   = FOC_QMAX;
 550   1          Vari.UD     = FOC__UD;
 551   1          Vari.DMAX   = FOC_DMAX;
 552   1          Vari.IQ     = FOC__IQ;
 553   1          Vari.THETA  = FOC__THETA;
 554   1          Vari.ETHETA = FOC__ETHETA;
 555   1          Vari.IQREF  = FOC_IQREF;
 556   1          
 557   1          if (mcState == mcRun)
 558   1          {
 559   2              mcFocCtrl.CurrentPower = FOC__POW << 3;                                           //Â∑¶ÁßªÊèêÈ´òÂä
             -üÁéáÂÄºÁ≤æÂ∫¶
 560   2              LPF_MDU(mcFocCtrl.CurrentPower, 1, mcFocCtrl.Powerlpf, mcFocCtrl.Powerlpf_LSB);   //Ê≥®ÊÑè‰ΩéÈÄöÊª
             -§Ê≥¢Âô®Á≥ªÊï∞ËåÉÂõ¥‰∏∫0---127
 561   2              LPF_MDU(FOC__UQ, 1, mcFocCtrl.UQ_lpf, mcFocCtrl.UQ_LSB);
 562   2          }
 563   1          
 564   1          if ((mcState != mcInit) && (mcState != mcReady))
 565   1          {
 566   2              LPF_MDU(FOC__EOME, 10, mcFocCtrl.SpeedFlt, mcFocCtrl.SpeedFlt_LSB);
 567   2              Atan_LPF_MDU(FOC__EALP, FOC__EBET, 10, mcFocCtrl.EsValue, mcFocCtrl.EsValue_LSB);
 568   2          }
 569   1          else
 570   1          {
 571   2              mcFocCtrl.SpeedFlt = 0;
 572   2          }
 573   1          
 574   1          Atan_Us_MDU(FOC__EALP, FOC__EBET, mcFocCtrl.EsValue);
 575   1          /* -----ÁéØË∑ØÂìçÂ∫î----- */
 576   1          Speed_response();                                                                      //ÁéØË∑ØÂìçÂ∫îÔ
             -ºåÂ¶ÇÈÄüÂ∫¶ÁéØ„ÄÅËΩ¨Áü©ÁéØ„ÄÅÂäüÁéáÁéØÁ≠â
 577   1          #if (!StartONOFF_Enable)
 578   1          {
 579   2              #if (SPEED_MODE == PWMMODE)
                      {
                          PWMInputCapture();
                      }
                      #elif (SPEED_MODE == NONEMODE)
 584   2              {
 585   3                  mcSpeedRamp.FlagONOFF   = 1;
 586   3                  mcSpeedRamp.TargetValue = Motor_Speed(speed);
 587   3              }
 588   2              #elif ( SPEED_MODE == SREFMODE)
                      {
                          VSPSample();
                      }
                      #endif
 593   2          }
 594   1          #elif (StartONOFF_Enable)
                  /* -----ÂêØÂÅúÊµãËØï----- */
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 11  

                  ONOFF_Starttest();
                  #endif
 598   1          #if (VOLTAGEMode ==Inter_VOLTAGE)
 599   1          AdcSampleValue.ADCDcbus = ADC14_DR;
 600   1          #else
                  AdcSampleValue.ADCDcbus = ADC2_DR;
                  #endif
 603   1          LPF_MDU((AdcSampleValue.ADCDcbus), 50, mcFocCtrl.mcDcbusFlt, mcFocCtrl.mcDcbusFlt_LSB);  //DCbusÈááÊ†∑
             -Êª§Ê≥¢ÂÄº
 604   1          /* -----ÊïÖÈöú‰øùÊä§ÂáΩÊï∞----- */
 605   1          Fault_Detection();
 606   1          
 607   1          if (mcFocCtrl.State_Count > 0)                                                           //ÁîµÊú∫Áä∂ÊÄ
             -ÅÊú∫Êó∂Â∫èÂ§ÑÁêÜ
 608   1          {
 609   2              mcFocCtrl.State_Count--;
 610   2          }
 611   1          
 612   1          if (BEMFDetect.BEMFTimeCount > 0)
 613   1          {
 614   2              BEMFDetect.BEMFTimeCount--;
 615   2          }
 616   1          
 617   1          #if (Open_Start_Mode == PLL_Start)
                  {
                      PLLfunction.UBASE_Factor = (float)(mcFocCtrl.mcDcbusFlt) * 16383 / ((float)(U_BASE));
                      
                      if (PLLfunction.UBASE_Factor < 10000)
                      {
                          PLLfunction.UBASE_Factor = 10000;
                      }
                  }
                  #endif
 627   1          /* -----ÁîµÊú∫ÂêØÂä®Áà¨Âù°ÂáΩÊï∞Â§ÑÁêÜ----- */
 628   1          StarRampDealwith();
 629   1          
 630   1          if (mcState == mcRun)
 631   1          {
 632   2              SetBit(TIM4_CR1, T4EN);
 633   2          }
 634   1          else
 635   1          {
 636   2              ClrBit(TIM4_CR1, T4EN);
 637   2              TIM4__DR = 5000;
 638   2              TIM4__ARR = 10000;
 639   2              TIM4__CNTR = 0;
 640   2          }
 641   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2329    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    336       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      9    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
C51 COMPILER V9.00   ADDFUNCTION                                                           01/15/2025 09:25:07 PAGE 12  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
