C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MOTORPROTECT
OBJECT MODULE PLACED IN .\Debug\MotorProtect.obj
COMPILER INVOKED BY: E:\KEIL\KEIL4\C51\BIN\C51.EXE ..\User\source\Function\MotorProtect.c LARGE OMF2 BROWSE INCDIR(..\FU
                    -68xx_Hardware_Driver\Include;..\User\include) DEBUG PRINT(.\Listings\MotorProtect.lst) OBJECT(.\Debug\MotorProtect.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2022 Fortiortech ShenZhen -----------------------------
   2              File Name      : MotorProtect.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2022-12-09
   6              Description    : This file contains XX-XX-XX function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------  
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          
  11          #include <FU68xx_4.h>
  12          #include <Myproject.h>
  13          
  14          FaultVarible         xdata   mcFaultDect;
  15          CurrentVarible       xdata   mcCurVarible;
  16          ProtectVarible       xdata   mcProtectTime;
  17          
  18          /* -------------------------------------------------------------------------------------------------
  19              Function Name  : Fault_OverUnderVoltage
  20              Description    : Ê¨†ËøáÂéã‰øùÊä§
  21              Date           : 2021-12-28
  22              Parameter      : h_Fault: [ËæìÂÖ•/Âá∫]
  23          ------------------------------------------------------------------------------------------------- */
  24          void Fault_OverUnderVoltage(void)
  25          {
  26   1          if (mcFaultSource == FaultNoSource)
  27   1          {
  28   2              //ËøáÂéã‰øùÊä§
  29   2              if (mcFocCtrl.mcDcbusFlt > OVER_PROTECT_VALUE)
  30   2              {
  31   3                  mcFaultDect.OverVoltDetecCnt++;
  32   3                  
  33   3                  if (mcFaultDect.OverVoltDetecCnt > 30)
  34   3                  {
  35   4                      mcFaultDect.OverVoltDetecCnt = 0;
  36   4                      mcFaultSource             = FaultOverVoltage;
  37   4                  }
  38   3              }
  39   2              else if (mcFaultDect.OverVoltDetecCnt > 0)
  40   2              {
  41   3                  mcFaultDect.OverVoltDetecCnt--;
  42   3              }
  43   2              
  44   2              //Ê¨†Âéã‰øùÊä§
  45   2              if (mcFocCtrl.mcDcbusFlt < UNDER_PROTECT_VALUE)
  46   2              {
  47   3                  mcFaultDect.UnderVoltDetecCnt++;
  48   3                  
  49   3                  if (mcFaultDect.UnderVoltDetecCnt > 30)
  50   3                  {
  51   4                      mcFaultDect.UnderVoltDetecCnt = 0;
  52   4                      mcFaultSource              = FaultUnderVoltage;
  53   4                  }
  54   3              }
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 2   

  55   2              else if (mcFaultDect.UnderVoltDetecCnt > 0)
  56   2              {
  57   3                  mcFaultDect.UnderVoltDetecCnt--;
  58   3              }
  59   2          }   
  60   1      }
  61          /* -------------------------------------------------------------------------------------------------
  62              Function Name  : Fault_Overcurrent
  63              Description    : ËΩØ‰ª∂ËøáÊµÅ‰øùÊä§
  64              Date           : 2021-12-28
  65              Parameter      : h_Cur: [ËæìÂÖ•/Âá∫]
  66          ------------------------------------------------------------------------------------------------- */
  67          void Fault_Overcurrent(void)
  68          {
  69   1          if ((mcState == mcRun) || (mcState == mcStart))
  70   1          {
  71   2              mcCurVarible.Max_ia = FOC__IAMAX;
  72   2              mcCurVarible.Max_ib = FOC__IBMAX;
  73   2              mcCurVarible.Max_ic = FOC__ICMAX;
  74   2              
  75   2              if ((mcCurVarible.Max_ia >= OverSoftCurrentValue) || (mcCurVarible.Max_ib >= OverSoftCurrentValue)
             - || (mcCurVarible.Max_ic >= OverSoftCurrentValue))
  76   2              {
  77   3                  mcCurVarible.OverCurCnt++;
  78   3                  
  79   3                  if (mcCurVarible.OverCurCnt >= OverSoftCurrentTimes)
  80   3                  {
  81   4                      mcFaultSource     = FaultSoftOVCurrent;
  82   4                      mcCurVarible.Max_ia     = 0;
  83   4                      mcCurVarible.Max_ib     = 0;
  84   4                      mcCurVarible.Max_ic     = 0;
  85   4                      mcCurVarible.OverCurCnt = 0;
  86   4                  }
  87   3              }
  88   2              else if (mcCurVarible.OverCurCnt > 0)
  89   2              {
  90   3                  mcCurVarible.OverCurCnt--;
  91   3              }
  92   2          }
  93   1      }
  94          /* -------------------------------------------------------------------------------------------------
  95              Function Name  : Fault_Start
  96              Description    : ÂêØÂä®‰øùÊä§ÂáΩÊï∞
  97              Date           : 2021-12-28
  98              Parameter      : h_Fault: [ËæìÂÖ•/Âá∫]
  99          ------------------------------------------------------------------------------------------------- */
 100          void Fault_Start(void)
 101          {
 102   1          if (mcState == mcRun)
 103   1          {
 104   2              if (mcFaultDect.StartSpeedCnt <= 5000)         //5ÁßíÂÜÖÈÄüÂ∫¶Â§ß‰∫éÊúÄÂ§ßÈÄüÂ∫¶ÔºåÂêåÊó∂ÂèçÁîµÂä®
             -ÂäøÂÄº‰Ωé‰∫é‰∏ÄÂÆöÂÄº
 105   2              {
 106   3                  mcFaultDect.StartSpeedCnt++;
 107   3                  
 108   3                  if ((mcFocCtrl.SpeedFlt > Motor_Stall_Max_Speed) && (mcFocCtrl.EsValue < 500))
 109   3                  {
 110   4                      mcFaultDect.StartSpeedCnt = 0;
 111   4                      mcFaultSource          = FaultStart;
 112   4                      mcProtectTime.StartFlag = 1;
 113   4                  }
 114   3              }
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 3   

 115   2              
 116   2              //ÊñπÊ≥ï‰∫å
 117   2              if (mcFaultDect.StartEsCnt <= 6000)            //Ââç6sÔºåÁ≠âÂæÖ2sÂêéÔºåÂºÄÂßãÂà§Êñ≠ESÔºåÂ¶ÇÊûúË∂ÖË
             -øá‰∏ÄÂÆöÊ¨°Êï∞ÔºåÂàôÂ§±Ë¥•
 118   2              {
 119   3                  mcFaultDect.StartEsCnt++;
 120   3                  mcFaultDect.StartDelay++;
 121   3                  
 122   3                  if (mcFaultDect.StartDelay >= 2000)         // 2s
 123   3                  {
 124   4                      mcFaultDect.StartDelay = 2000;
 125   4                      
 126   4                      if ((mcFocCtrl.EsValue < 1000))
 127   4                      {
 128   5                          mcFaultDect.StartESCount++;
 129   5                          
 130   5                          if (mcFaultDect.StartESCount >= 100)//ms
 131   5                          {
 132   6                              mcFaultSource = FaultStart;
 133   6                              mcFaultDect.StartDelay     = 0;
 134   6                              mcFaultDect.StartESCount   = 0;
 135   6                              mcProtectTime.StartFlag = 2;
 136   6                          }
 137   5                      }
 138   4                      else
 139   4                      {
 140   5                          if (mcFaultDect.StartESCount > 0)
 141   5                          {
 142   6                              mcFaultDect.StartESCount--;
 143   6                          }
 144   5                      }
 145   4                  }
 146   3              }
 147   2              else
 148   2              {
 149   3                  mcFaultDect.StartESCount = 0;
 150   3              }
 151   2              
 152   2              //ÊñπÊ≥ï‰∏âÔºåÈïøÊó∂Èó¥Âú®CtrlMode=0Áä∂ÊÄÅ
 153   2              if (mcFocCtrl.CtrlMode == 0)                //mcFocCtrl.CtrlMode =0Âú®ÂºÄÁéØÁä∂ÊÄÅÔºåmcFocCtrl.Ctr
             -lMode=1Âú®Èó≠ÁéØÁä∂ÊÄÅ
 154   2              {
 155   3                  mcFaultDect.StartFocmode++;
 156   3                  
 157   3                  if (mcFaultDect.StartFocmode >= 2000)       //2ÁßíÂêé
 158   3                  {
 159   4                      mcFaultDect.StartFocmode = 0;
 160   4                      mcFaultSource         = FaultStart;
 161   4                      mcProtectTime.StartFlag = 3;
 162   4                  }
 163   3              }
 164   2          }
 165   1      }
 166          /* -------------------------------------------------------------------------------------------------
 167              Function Name  : Fault_Stall
 168              Description    : Â†µËΩ¨‰øùÊä§
 169              Date           : 2021-12-28
 170              Parameter      : h_Fault: [ËæìÂÖ•/Âá∫]
 171          ------------------------------------------------------------------------------------------------- */
 172          void Fault_Stall(void)
 173          {
 174   1          if (mcState == mcRun)
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 4   

 175   1          {
 176   2              if (mcFaultDect.StallDelayCnt <= 2000) //2s  
 177   2              {
 178   3                  mcFaultDect.StallDelayCnt++;
 179   3              }
 180   2              else
 181   2              {
 182   3                  if ((mcFocCtrl.EsValue < 1000) || ((FOC__EOME > _Q15(3000.0 / MOTOR_SPEED_BASE)) && (mcFocCtrl
             -.EsValue < 1000)))
 183   3                  {
 184   4                      mcFaultDect.StallDectEs++;
 185   4                      
 186   4                      if (mcFaultDect.StallDectEs >= 500)//ms
 187   4                      {
 188   5                          mcFaultDect.StallDectEs = 0;
 189   5                          mcFaultSource        = FaultStall;
 190   5                          mcProtectTime.StallFlag = 1;
 191   5                      }
 192   4                  }
 193   3                  else
 194   3                  {
 195   4                      if (mcFaultDect.StallDectEs > 0)
 196   4                      {
 197   5                          mcFaultDect.StallDectEs--;
 198   5                      }
 199   4                  }
 200   3                  
 201   3                  if (mcFocCtrl.SpeedFlt > (uint32)mcFocCtrl.EsValue * 7)
 202   3                  {
 203   4                      mcFaultDect.StallTimes++;
 204   4                      
 205   4                      if (mcFaultDect.StallTimes >= 500)//ms
 206   4                      {
 207   5                          mcFaultDect.StallTimes = 0;
 208   5                          mcFaultSource        = FaultStall;
 209   5                          FaultProcess();
 210   5                          mcProtectTime.StallFlag = 2;
 211   5                      }
 212   4                  }
 213   3                  else
 214   3                  {
 215   4                      if (mcFaultDect.StallTimes > 0)
 216   4                      {
 217   5                          mcFaultDect.StallTimes--;
 218   5                      }
 219   4                  }
 220   3                  
 221   3                  //Âà§Êñ≠ÈÄüÂ∫¶‰Ωé‰∫éÂ†µËΩ¨ÊúÄÂ∞èÂÄºÊàñËÄÖË∂ÖËøáÂ†µËΩ¨ÊúÄÂ§ßÂÄº
 222   3                  if ((mcFocCtrl.SpeedFlt < Motor_Stall_Min_Speed) || (mcFocCtrl.SpeedFlt > Motor_Stall_Max_Spee
             -d))
 223   3                  {
 224   4                      mcFaultDect.StallDectSpeed++;
 225   4                      
 226   4                      if (mcFaultDect.StallDectSpeed >= 500)//ms
 227   4                      {
 228   5                          mcFaultDect.StallDectSpeed = 0;
 229   5                          mcFaultSource           = FaultStall;
 230   5                          mcProtectTime.StallFlag = 3;
 231   5                      }
 232   4                  }
 233   3                  else
 234   3                  {
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 5   

 235   4                      if (mcFaultDect.StallDectSpeed > 0)
 236   4                      {
 237   5                          mcFaultDect.StallDectSpeed--;
 238   5                      }
 239   4                  }
 240   3              }
 241   2          }   
 242   1      }
 243          /* -------------------------------------------------------------------------------------------------
 244              Function Name  : Fault_phaseloss
 245              Description    : Áº∫Áõ∏‰øùÊä§
 246              Date           : 2021-12-28
 247              Parameter      : h_Fault: [ËæìÂÖ•/Âá∫]
 248          ------------------------------------------------------------------------------------------------- */
 249          void Fault_phaseloss(void)
 250          {
 251   1          if (mcState == mcRun)
 252   1          {
 253   2              mcFaultDect.Lphasecnt++;
 254   2              
 255   2              if (mcFaultDect.Lphasecnt > 500) 
 256   2              {
 257   3                  mcFaultDect.Lphasecnt = 0;
 258   3                  
 259   3                  
 260   3                  if (((mcCurVarible.Max_ia > (mcCurVarible.Max_ib * PhaseLossTimes)) || (mcCurVarible.Max_ia > 
             -(mcCurVarible.Max_ic * PhaseLossTimes)))
 261   3                      && (mcCurVarible.Max_ia > PhaseLossCurrentValue))
 262   3                  {
 263   4                      mcFaultDect.AOpencnt++;
 264   4                  }
 265   3                  else
 266   3                  {
 267   4                      if (mcFaultDect.AOpencnt > 0)
 268   4                      {
 269   5                          mcFaultDect.AOpencnt --;
 270   5                      }
 271   4                  }
 272   3                  
 273   3                  if (((mcCurVarible.Max_ib > (mcCurVarible.Max_ia * PhaseLossTimes)) || (mcCurVarible.Max_ib > 
             -(mcCurVarible.Max_ic * PhaseLossTimes)))
 274   3                      && (mcCurVarible.Max_ib > PhaseLossCurrentValue))
 275   3                  {
 276   4                      mcFaultDect.BOpencnt++;
 277   4                  }
 278   3                  else
 279   3                  {
 280   4                      if (mcFaultDect.BOpencnt > 0)
 281   4                      {
 282   5                          mcFaultDect.BOpencnt --;
 283   5                      }
 284   4                  }
 285   3                  
 286   3                  if (((mcCurVarible.Max_ic > (mcCurVarible.Max_ia * PhaseLossTimes)) || (mcCurVarible.Max_ic > 
             -(mcCurVarible.Max_ib * PhaseLossTimes)))
 287   3                      && (mcCurVarible.Max_ic > PhaseLossCurrentValue))
 288   3                  {
 289   4                      mcFaultDect.COpencnt++;
 290   4                  }
 291   3                  else
 292   3                  {
 293   4                      if (mcFaultDect.COpencnt > 0)
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 6   

 294   4                      {
 295   5                          mcFaultDect.COpencnt --;
 296   5                      }
 297   4                  }  
 298   3      
 299   3                  if ((mcCurVarible.Max_ic < PhaseLossCurrentValue) && (mcCurVarible.Max_ib < PhaseLossCurrentVa
             -lue) && (mcCurVarible.Max_ia < PhaseLossCurrentValue))
 300   3                  {
 301   4                      mcFaultDect.ABCOpencnt++;
 302   4                      
 303   4                      if(mcFaultDect.ABCOpencnt>=2)
 304   4                      {
 305   5                         mcFaultDect.ABCOpencnt = 0;
 306   5                         mcFaultSource = FaultLossPhase;                                    
 307   5                      }
 308   4      
 309   4                  }
 310   3                  else
 311   3                  {
 312   4                      mcFaultDect.ABCOpencnt = 0;
 313   4                  }            
 314   3                  
 315   3                  mcCurVarible.Max_ia = 0;
 316   3                  mcCurVarible.Max_ib = 0;
 317   3                  mcCurVarible.Max_ic = 0;
 318   3                  
 319   3                  SetBit(FOC_CR2, ICLR);
 320   3                  
 321   3                  if ((mcFaultDect.AOpencnt > 1) || (mcFaultDect.BOpencnt > 1) || (mcFaultDect.COpencnt > 1))
 322   3                  {           
 323   4                      mcFaultSource = FaultLossPhase;
 324   4                  }                                                                                             
             -                                                  
 325   3                  
 326   3              }
 327   2          }
 328   1      }
 329          
 330          void Fault_Recovery(void)
 331          {
 332   1          #if (!StartONOFF_Enable)
 333   1          {
 334   2              /*******ËøáÂéãÊ¨†Âéã‰øùÊä§ÊÅ¢Â§ç*********/
 335   2              if ((mcState == mcFault) && ((mcFaultSource == FaultUnderVoltage) || (mcFaultSource == FaultOverVo
             -ltage)))
 336   2              {
 337   3                  if ((mcFocCtrl.mcDcbusFlt < OVER_RECOVER_VALUE) && (mcFocCtrl.mcDcbusFlt > UNDER_RECOVER_VALUE
             -))
 338   3                  {
 339   4                      mcFaultDect.VoltRecoverCnt++;
 340   4                      
 341   4                      if (mcFaultDect.VoltRecoverCnt > VOU_Recover_Time)
 342   4                      {
 343   5                          mcFaultSource           = FaultNoSource;
 344   5                          mcFaultDect.VoltRecoverCnt = 0;
 345   5                      }
 346   4                  }
 347   3                  else
 348   3                  {
 349   4                      mcFaultDect.VoltRecoverCnt = 0;
 350   4                  }
 351   3              }
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 7   

 352   2              /*******ÂêØÂä®‰øùÊä§ÊÅ¢Â§ç*********/ 
 353   2              if ((mcFaultSource == FaultStart) && (mcState == mcFault) && (mcProtectTime.SecondStartTimes < Sta
             -rtProtectRestartTimes))
 354   2              {
 355   3                  mcFaultDect.StartReCount++;
 356   3                  
 357   3                  if (mcFaultDect.StartReCount >= StartRecoverTime)
 358   3                  {
 359   4                      mcFaultDect.StartReCount = 0;
 360   4                      mcProtectTime.SecondStartTimes++;
 361   4                      mcFaultSource         = FaultNoSource;
 362   4                  }
 363   3              }
 364   2              else
 365   2              {
 366   3                  mcFaultDect.StartReCount = 0;
 367   3              } 
 368   2      
 369   2              /*******Â†µËΩ¨‰øùÊä§ÊÅ¢Â§ç*********/
 370   2              if ((mcFaultSource == FaultStall) && (mcState == mcFault) && (mcProtectTime.StallTimes < StallProt
             -ectRestartTimes))
 371   2              {
 372   3                  mcFaultDect.StallReCount++;
 373   3                  
 374   3                  if (mcFaultDect.StallReCount >= StallRecoverTime)
 375   3                  {
 376   4                      mcFaultDect.StallReCount = 0;
 377   4                      mcProtectTime.StallTimes++;
 378   4                      mcFaultSource         = FaultNoSource;
 379   4                  }
 380   3              }
 381   2              else
 382   2              {
 383   3                  mcFaultDect.StallReCount = 0;
 384   3              }
 385   2          
 386   2              /*******Áº∫Áõ∏‰øùÊä§ÊÅ¢Â§ç*********/
 387   2              if ((mcFaultSource == FaultLossPhase) && (mcState == mcFault) && (mcProtectTime.LossPHTimes < Phas
             -eLossRestartTimes)) //ÂèØÈáçÂêØ5Ê¨°
 388   2              {
 389   3                  mcFaultDect.mcLossPHRecCount++;
 390   3                  
 391   3                  if (mcFaultDect.mcLossPHRecCount >= PhaseLossRecoverTime)
 392   3                  {
 393   4                      mcProtectTime.LossPHTimes++;
 394   4                      mcFaultDect.AOpencnt = 0;
 395   4                      mcFaultDect.BOpencnt = 0;
 396   4                      mcFaultDect.COpencnt = 0;
 397   4                      mcFaultSource     = FaultNoSource;
 398   4                  }
 399   3              }
 400   2              else
 401   2              {
 402   3                  mcFaultDect.mcLossPHRecCount = 0;
 403   3              }
 404   2              
 405   2               /*******ËøáÊµÅ‰øùÊä§ÊÅ¢Â§ç*********/ 
 406   2              if ((mcState == mcFault) && ((mcFaultSource == FaultSoftOVCurrent) || (mcFaultSource == FaultHardO
             -VCurrent)) && (mcProtectTime.CurrentPretectTimes < OverCurrentRestartTimes))
 407   2              {
 408   3                  mcFaultDect.CurrentRecoverCnt++;
 409   3                  
C51 COMPILER V9.00   MOTORPROTECT                                                          01/15/2025 09:25:07 PAGE 8   

 410   3                  if (mcFaultDect.CurrentRecoverCnt >= OverCurrentRecoverTime)
 411   3                  {
 412   4                      mcFaultDect.CurrentRecoverCnt = 0;
 413   4                      mcProtectTime.CurrentPretectTimes++;
 414   4                      mcFaultSource = FaultNoSource;
 415   4                  }
 416   3              }
 417   2      
 418   2              
 419   2          }
 420   1          #endif       
 421   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2288    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     65    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
